package dynamilize;

/**
 * The interfaces that all dynamic objects depend on describe the basic behaviors that dynamic objects have, and the implementation of the interfaces should be generated by the generator.
 * <p>The implementation of this interface should usually not be done externally, but should be generated through {@link DynamicMaker#makeClassInfo(Class, Class[], Class[])}. The implementation classes generated by the generator should satisfy the following behaviors:
 * <ul>
 * <li>Assign a field to save the {@linkplain DataPool object}, which has a private final modifier
 * <li>Assign objects to save fields of the {@linkplain DynamicClass dynamic class}, which have the private final modifier.
 * <li>Generate a corresponding constructor for each superclass constructor and correctly call the corresponding superclass constructor for the superclass.
 * Two new parameters are added before the parameters, which are passed into the {@linkplain DataPool data pool} and {@linkplain DynamicClass dynamic class} respectively, and assigned to member fields.
 * <li>Implement the various abstract methods of the interface according to the method instructions within this interface.
 * </ul>
 * And the constructor of the delegate type should be called from several newInstances in {@link DynamicMaker}, otherwise you must provide appropriate constructor parameters for them.
 */
@SuppressWarnings("unchecked")
public interface DynamicObject<S> {
    /**
     * Get the dynamic type of the object.
     * <p>The implementation of the generator should implement this method to return the generated dynamic type field.
     * @return The dynamic type of this object
     */
    DynamicClass getDyClass();

    /**
     * Obtain the member variables of the object.
     * <p>The generator implementation should implement this method to call the {@link DataPool#getVariable(String)} method of the data pool and return a value.
     * @param name Variable name
     * @return Value of variable
     */
    IVariable getVariable(String name);

    DataPool.ReadOnlyPool baseSuperPointer();

    /**
     * Set member variables for objects.
     * <p>The generator implementation should implement this method to call the {@link DataPool#setVariable(IVariable)} method of the data pool, with its own parameters passed in separately.
     * @param variable Set the variables.
     */
    void setVariable(IVariable variable);

    /**
     * Get the value of a member variable of an object. If the variable has not been defined, an exception will be thrown.
     * @param name Variable name
     * @return Variable value
     */
    default <T> T getVar(String name) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this);
    }

    /**
     * Set a property value for a variable of an object. If the variable cannot be found in the hierarchy, it will be defined.
     * @param name Variable name
     * @param value Attribute value
     */
    default <T> void setVar(String name, T value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    <T> T varValueGet(String name);

    <T> void varValueSet(String name, T value);

    /**
     * Process the variable with the specified name using the given operator, and set the variable value based on its calculation result.
     * @param name Variable name
     * @param calculator calculator
     * @return Calculation results
     */
    default <T> T calculateVar(String name, Calculator<T> calculator) {
        T res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    /**
     * Anonymous function representation for obtaining the function of an object.
     * <p>The generator implementation should implement this method to call the {@link DataPool#select(String, FunctionType)} method of the data pool and return a value.
     * @param name Function name
     * @param type Parameterf types of functions
     * @return Anonymous representation of specified function
     */
    IFunctionEntry getFunc(String name, FunctionType type);

    default <R> Delegate<R> getFunction(String name, FunctionType type) {
        IFunctionEntry entry = getFunc(name, type);
        if (entry == null)
            throw new IllegalHandleException("no such function: " + name + type);

        return a -> (R) entry.<S, R>getFunction().invoke(this, a);
    }

    default <R> Delegate<R> getFunction(String name, Class<?>... types) {
        FunctionType type = FunctionType.inst(types);
        Delegate<R> f = getFunction(name, type);
        type.recycle();
        return f;
    }

    default <R> Function<S, R> getFunc(String name, Class<?>... types) {
        FunctionType type = FunctionType.inst(types);
        Function<S, R> f = getFunc(name, type).getFunction();
        type.recycle();
        return f;
    }

    /**
     * Set the member functions of an object in lambda mode. Function changes to an object in lambda mode are only valid for that object and take effect immediately,
     * If the change needs to be effective for all instances, the dynamic type reference {@link DynamicClass#visitClass(Class, JavaHandleHelper)} method of this object should be used to change the behavior template.
     * <p>The generator implementation should implement this method to call the {@link DataPool#setFunction(String, Function, Class[])} method of the data pool and pass the parameters in one-to-one correspondence.
     * <p><strong>Note that for parameters containing generics, regardless of the type parameter, the formal parameter type is always {@link Object}</strong>
     *
     * @param name Function name set
     * @param func Anonymous functions that describe function behavior
     * @param argTypes List of types for formal parameters
     */
    <R> void setFunc(String name, Function<S, R> func, Class<?>... argTypes);

    <R> void setFunc(String name, Function.SuperGetFunction<S, R> func, Class<?>... argTypes);

    /** Same as {@link DynamicObject#setFunc(String, Function, Class[])}, except that the passed function does not return a value. */
    default void setFunc(String name, Function.NonRetFunction<S> func, Class<?>... argTypes) {
        setFunc(name, (s, a) -> {
            func.invoke(s, a);
            return null;
        }, argTypes);
    }

    /** Same as {@link DynamicObject#setFunc(String, Function.SuperGetFunction, Class[])}, except that the passed function does not return a value. */
    default void setFunc(String name, Function.NonRetSuperGetFunc<S> func, Class<?>... argTypes) {
        setFunc(name, (s, sup, a) -> {
            func.invoke(s, sup, a);
            return null;
        }, argTypes);
    }

    /**
     * Execute the specified member function of the object.
     * @param name Function name
     * @param args List of arguments passed to the function.
     * @return Function return value
     */
    default <R> R invokeFunc(String name, Object... args) {
        ArgumentList lis = ArgumentList.as(args);
        R r = invokeFunc(name, lis);
        lis.type().recycle();
        lis.recycle();
        return r;
    }

    /**
     * Indicate the specified member function of the formal parameter list execution object. If there are objects derived from types or null values in the parameters,
     * using type to explicitly specify the formal parameter type can effectively improve execution efficiency.
     * @param name Function name
     * @param args List of arguments passed to the function.
     * @return Function return value
     */
    default <R> R invokeFunc(FunctionType type, String name, Object... args) {
        ArgumentList lis = ArgumentList.asWithType(type, args);
        R r = invokeFunc(name, lis);
        lis.recycle();
        return r;
    }

    /**
     * Directly passing {@link ArgumentList} as a function call for the argument list, unboxing is completed within the method,
     * making it easier to reference another function in an anonymous function without unboxing.
     * @param name Function name
     * @param args It is a list of encapsulated objects
     * @return Function return value
     */
    default <R> R invokeFunc(String name, ArgumentList args) {
        FunctionType type = args.type();
        Function<S, R> res = getFunc(name, type).getFunction();

        if (res == null)
            throw new IllegalHandleException("no such method declared: " + name);

        return res.invoke( this, args);
    }

    /** Perform a strong transformation on the object itself and return it. */
    default <T extends S> T objSelf() {
        return (T) this;
    }

    //primitive getters and setters
    //I hate packing types, yes, quite annoying......
    default boolean getVar(String name, boolean def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default byte getVar(String name, byte def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default short getVar(String name, short def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default int getVar(String name, int def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default long getVar(String name, long def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default float getVar(String name, float def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default double getVar(String name, double def) {
        IVariable var = getVariable(name);
        if (var == null)
            throw new IllegalHandleException("variable " + name + " was not defined");

        return var.get(this, def);
    }

    default void setVar(String name, boolean value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, byte value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, short value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, int value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, long value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, float value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default void setVar(String name, double value) {
        IVariable var = getVariable(name);
        if (var == null) {
            var = new Variable(name);
            setVariable(var);
        }
        var.set(this, value);
    }

    default boolean calculateVar(String name, Calculator.BoolCalculator calculator) {
        boolean res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default byte calculateVar(String name, Calculator.ByteCalculator calculator) {
        byte res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default short calculateVar(String name, Calculator.ShortCalculator calculator) {
        short res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default int calculateVar(String name, Calculator.IntCalculator calculator) {
        int res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default long calculateVar(String name, Calculator.LongCalculator calculator) {
        long res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default float calculateVar(String name, Calculator.FloatCalculator calculator) {
        float res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }

    default double calculateVar(String name, Calculator.DoubleCalculator calculator) {
        double res;
        setVar(name, res = calculator.calculate(getVar(name)));
        return res;
    }
}
